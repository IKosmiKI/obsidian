Полиморфизм - разная реакция на одинаковый запрос в зависимости от кого этот запрос пришел
Инкапсуляция - это принцип ООП, который позволяет объединять данные и методы в классах или управлять доступом к ним. Так же позволяет работать с этими объединениями без понимания их внутренней структуры
C++ позволяет классу наследовать элементы-данных и элементы-функции одного или нескольких других классов. Иначе говоря новый класс может получать атрибуты и поведение от уже существующего класса. Новый класс называют производным классом. Класс, элементы которого наследуются, называется базовым классом. При наследовании более ярко проявляется важное свойство ООП - инкапсуляция. Смысл инкапсуляции состоит в том, что набор некоторых свойств и поведений помещается в общую оболочку и есть возможность работать с этой оболочкой без понимания ее внутренней структуры. При наследовании даже авторы классов могут работать с базовыми классами без понимания этой внутренней структуры.
В производном классе можно добавить новые элементы-данные и жлементы-функции, а также переопределить элементы-функции базового класса. При этом смысл наследование состоит в том, чтобы основной объем свойств базового класса сохранялся.
Синтаксис наследования имеет вид:
```cpp
class имя_сына:ключ_доступа имя_отца 
```
Ключ доступа, находящийся в строке определения класса-насленика - это public, private или protected. Он может отсутствовать, тогда будет применяться доступ по умолчанию (как обычно). Этот ключ доступа совместно с ключом доступа, находящемся в базовом классе, влияет на возможность доступа к элементам базового класса через объекты класса-сына. Эта возможность соответствует более жесткому из пары ключей доступа. При этом ключ доступа, находящийся в строке определения класса наследника, не влияет на доступ из функция производного класса к унаследованным элементам базового класса.
```cpp
class prolet: public prverka {
	char* stroka;
	public: prolet (char*, int, int);
	friend void print (const proverka&);
	void print1 (void)
		{
		proverka zaval(a,b); #не работает т.к a и b в привате
		print (zaval);
		print ("%s", stroka;)
		};
};
prolet::prolet (char* str, int a1, int b1) : proverka (a1, b1) {
	strcpy (stroka, str);
	}
void main () {
	prolet idb2316("Otchislen", 25, 25);
	idb2316.print1();
}
```