## 3.1 Определение класса
Класс можно считать расширением понятия типа данных, определяемого программистом(структурного типа данных). Он определяется точно так же, как и структурный тип языка C, но с некоторыми расширениями:
1. определение класса может содержать 1 или несколько спецификаторов(меток) доступа, которые отвечают за возможность доступа из различных точек программы к компонентам класса
2. при создании класса можно использовать не только ключевое слово `struct`, но и ключевое слово `class`. Более того, в  С++  ключевое слово `union` тоже задает класс
3. на ряду с компонентами класса, хранящими данные, можно добавлять в класс функции. Если функция приписана классу, то вызвать ее можно только используя переменную типа класса
4. часть функций класса относиться к специальным, для которых характерны: неявный вызов и автоматическая генерация, если программист не создал такую функцию

В C++ переменная, описанная как переменная типа класса, называется представителем класса или объектом
В C++ используются спецификаторы доступа `public`, `private` и `protected`. При использовании метки доступа `private` компоненты доступны только внутри функций этого же класса.
При использовании метки `protected` компоненты доступны только внутри функций этого класса и классов, производных от него (наследование)
При использовании метки `public` компоненты доступны из любой функции программы, в которой имеется представитель этого класса. 
Использование при описании класса в С++ ключевого слова `struct` отличается от использования ключевого слова `class` только доступом по умолчанию. (В классе - `private`)

## 3.2 Элементы класса
Элементы класса делятся на элементы-данные и элементы-функции (методы).
Элементы-данные мало отличаются от компонентов структурных типов из C. Элементом-данных не может быть объект этого же класса, но может быть указатель на объект класса.

Метод класса - это функция, у которой или прототип, или заголовок вместе с телом находятся в теле класса. Если в теле класса записан прототип, то за пределами класса размещается заголовок вместе с телом. В этом заголовке перед именем функции размещается имя класса и операция разрешения видимости (`имя_класса :: название_метода`). Если же в теле класса записан заголовок вместе с телом, то такая функция является встроенной и должна соответствовать ограничениям, наложенным на встроенные функции.

## 3.3 Правила обращения к элементам класса
Имена элементов класса могут использоваться со следующими формами синтаксиса: 
1. С существующим представителем класса, за которым следует точка
2. С указателем на существующий представитель класса, за которым следует стрелка
3. С именем класса, за которым следует двойное двоеточие(разрешение видимости)
4. Прямой доступ

Каждый из видов синтаксиса доступен только в определенном контексте с учетом места программы и правил доступа. Под прямым доступом понимается, что внутри тел функций элементов класса можно обращаться к другим функциям элемента этого же класса или к элементам данных этого же класса просто по имени без каких-бы то ни было приставок.

Можно объявить элемент класса (как данные, так и функции) статическим. Статический элемент класса существует только один, вне зависимости от того, сколько представителей класса создано в процессе работы программы.
Обратиться к открытому статическому элементу класса можно через любой представитель класса при помощи операций прямого или косвенного доступа, либо с  помощью операции разрешения видимости с использованием имени класса.

Если статический элемент - закрытый, то для доступа к нему в составе класса предусматривается открытая статическая функция-элемент. Такая функция может вызываться даже если не существует никаких представителей класса

## 3.4 Конструктор и деструктор
Конструкторы и деструкторы относятся к специальным функциям-элементам(есть и без нас и вызываются неявно). Конструктор вызывается при создании представителя класса, а деструктор - в момент его гибели. Нет никаких правил по поводу содержимого тел деструктора и конструктора, но, как правило, в теле конструктора инициализируются элементы данных, а в теле деструктора проводятся действия по очистке содержимого элементов данных.

Если автор класса не создавал конструктор или деструктор, то они создаются 
автоматически
Автоматический конструктор не имеет параметров, при создании хоть одного конструктора автором класса автоматический конструктор перестает действовать
Для конструктора не существует понятия типа возвращаемого значения, имя конструктор совпадает с именем класса, конструктор можно перегружать
Деструктор также не может иметь тип возвращаемого значения, но у него нет параметров. Имя деструктора состоит из **"~" + имя класса**
**Список инициализации -** это код, который прописывается по специальным правилам в заголовке конструктора. Использование списка инициализации - это альтернативный способ инициализации элементов данных (вместо из инициализации в теле конструктора)
`ploho (int aa, int bb) : a(aa), b(bb)`
## 3.5 Перегрузка операторов
В C++ разрешено переопределять для классов существующие обозначения операций. Это называется перегрузкой операций. В результате такой перегрузки для объектов классов можно будет использовать обозначения операций, привычные по работе с переменными базовых типов. Обычно программисты стараются перегружать операции таким образом, чтобы сохранялся смысл знаков операций. Многие стандартные классы, входящие в состав различных сред программирования используют возможность перегрузки операций. Например, так сделано в классе потоков **iostream**.
```
cout << "Hello, World!" << endl;
cin >> t;
```
Заголовок функции, перегружающей операцию имеет вид:
`тип operator знак_операции (параметры) {}`
Если функция является элементом класса, то первый операнд соответствующей операции будет именно тем объектом для которого вызывается функция, перегружающая операцию. Поэтому явно передавать этот объект в функцию не надо. Соответственно в случае унарной операции список параметров будет пуст, а при бинарной операции функция будет иметь 1 параметр, соответствующий второму операнду.
Если функция не принадлежит ни к какому классу, то она имеет 1 параметр в случае унарной операции и 2 в случае бинарной.
**Тернарная операция не перегружается**
Приоритеты и правила вычисления остаются для перегруженный операций такими же, что и для операций над встроенными типами. Поведение операции по отношению к базовому типу изменить нельзя ( то есть в операции должна принимать участие хотя бы одна переменная типа какого-нибудь класса ).