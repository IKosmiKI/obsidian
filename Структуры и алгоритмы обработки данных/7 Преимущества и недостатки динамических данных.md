Плюсы:
1. Разумное использование динамически размещаемых данных может привести к существенному сокращению объема оперативной памяти, необходимого для работы программы
2. Динамические данные - противоположность статическим и автоматическим данным - не требует объявления их как данных фиксированного размера. В большинстве вычислительных систем существует достаточно большой объем памяти, доступной для размещения динамических данных
3. Некоторые алгоритмы более эффективны при реализации их на динамических структурах. Например вставка нового элемента в середину структуры выполняется проще в динамических структурах данных

Минусы:
1. Алгоритмы на динамических данных и структурах обычно более сложные, менее понятные и более трудные для отладки по сравнению с аналогичными алгоритмами на статических структурах
2. Использование динамических структур связано с накладными расходами памяти, отводимой под поля связи. В некоторых случаях потребуется запоминание многих ссылок. Объем памяти, отводимый под них может существенно превосходить объем памяти, занимаемый непосредственно данными. В таком случае память под поля связи следует рассматривать как накладные расходы. Они могут оказаться весьма существенными при коротких полях данных. Существуют алгоритмы, реализация которых более эффективна на нединамических структурах. Во многих случаях индекс элемента массива можно вычислить непосредственно, в то время, как списковые решения будут требовать обход списка

**Основные операции со списками**
Программы, использующие связные списковые структуры, часто называют программами обработки списков. Можно выделить несколько операций и соответственно алгоритмов, которые наиболее часто используются при обработке списков. При выполнении этих операций необходимо учитывать состояние обрабатываемого списка, так как:
1. Список может быть пустым (не содержать ни одного элемента)
2. Список может быть не пустым (содержать какое-то количество элементов)

Кроме этого, при обработке списка всегда нужно рассматривать 3 случая:
1. Обработка 1-ого элемента
2. Обработка последнего элемента списка
3. Обработка элемента в середине списка

Для каждой из этих ситуаций часто требуется предусмотреть свой алгоритм обработки. При обработке списка всегда требуется знать, с каким конкретным элементом мы хотим работать. Это может быть элемент с нужным нам значением, с требуемым номером по порядку, и так далее. То есть он определяется условием задачи.
Для указания местонахождения нужного нам элемента вводится указатель. Он называется рабочий (текущий). Он показывает в каком месте списка мы сейчас находимся и его значение равно адресу элемента списка, на который он указывает. Очень часто этот адрес заранее не известен и для его обнаружения необходим обход списка. Чаще всего с первого, но возможно и с другого элемента списка. Основная идея обхода списков заключается в следующем: 
1. Устанавливаем рабочий указатель на начало списка
2. Проверяем, указывает ли рабочий указатель на нужный нам элемент. Если да, то шаг 3, если нет, то шаг 4
3. Заканчиваем алгоритм обхода и переходим к обработке
4. Устанавливаем рабочий указатель на следующий элемент списка и переходим на шаг 2

Данный алгоритм предусматривает ситуацию, в которой требуемый элемент присутствует в списке. Если такой элемент отсутствует, то алгоритм необходимо модифицировать. Иногда требуется просто пройтись по всем элементам списка не находя при этом никакого конкретного элемента. Тогда признаком конца обхода может стать значение рабочего указателя, равное 0. Можно выделить 2 основные операции над связными списками:
1. Операция включения (вставки) элемента в список. Она заключается в вставке нового элемента в требуемом месте списка. Порядок размещения старых элементов при этом не изменяется.
2. Удаление элемента из списка. При этом элемент удаляется, а все остальные элементы остаются на своих местах

**Операции включения и исключения элемента из односвязного списка**
Предположим, что у нас имеется некторый функциональный список с каким-то ко