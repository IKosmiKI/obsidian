## Сортировка
Сортировка (упорядочивание списка объектов) - такая перестановка этих объектов, при которой они располагаются в некотором определенном порядке.
Цель сортировки - облегчить поиск требуемого объекта в отсортированном списке.
Важные области применения сортировки:
1. Поиск общих элементов в двух или более массивах легче осуществлять, если все массивы отсортированы в одном и том же порядке
2. Решение задачи "Группирование". Цель задачи - есть некоторое количество объектов, расположенных случайным образом. Необходимо собрать вместе объекты, у которых некоторый признак имеет общее значение
3. Поиск информации по значениям ключей

**Задачи сортировки**
Предполагаем, что при сортировке мы работаем с некоторыми объектами (характеризуется некими данными). Предположим, что в рамках некоторой предметной области мы решаем некоторую задачу. Для решения этой задачи мы выделяем объекты, которыми можно оперировать в рамках этой предметной области. Каждый объект распознается в предметной области по своим характеристикам и может быть выделен в ней среди других объектов. Предположим, что для каждого объекта все его характеристики мы помещаем в некоторую запись. Тогда для того, чтобы выделить некоторый конкретный объект среди множества объектов нам необходимо иметь некоторый признак в записи, который:
1. позволяет отсылать нас к нужному нам объекту
2. даст нам возможность выделить запись об этом объекте среди других записей. С этой целью в записи предусматривается поле, которое является ключевым полем (ключом). Ключ должен идентифицировать запись

Задача сортировки звучит следующим образом: имеется n записей b1-bn. В каждой записи bj имеется ключевое поле kj, которое управляет процессом сортировки. Помимо ключевого поля запись может иметь множество других полей, но они не влияют на процесс сортировки. Поэтому в алгоритмах сортировки речь идет только о ключевом поле, а остальные поля опускаются. Задача сортировки состоит в том, что необходимо найти такую перестановку записей(b1-bn, с ключами k1-kn), после которой ключи записей расположились бы в порядке не убывания (возрастания).
Метод сортировки называется устойчивым, если в процессе сортировки относительно положение элементов с равными ключами не меняется. Устойчивость сортировки бывает необходимо тогда, когда элементы уже были упорядочены по некоторым вторичным ключам (ключам, по которым сортировка была произведена до этого и не связаны с теперешними ключами)

**Внутренние и внешние сортировки**
Выбор алгоритма зависит от структуры обрабатываем данных и методы сортировки хорошо и наглядно это демонстрируют. Все методы сортировки делятся на 2 класса:
1. Внутренняя сортировка (сортировка массивов)
2. Внешняя сортировка (сортировка файлов)

Такое деление обусловлено следующим - место в оперативной памяти ограничено. Если возможно разместить данные единовременно в памяти, то можно применять внутреннюю сортировку, а если нет, то внешнюю.
К настоящему времени разработано множество различных алгоритмов как для внутренней, так и для внешней сортировок. Так же могут появляться новые алгоритмы. Это связано с тем, что нельзя разработать самый эффективный алгоритм на все случаи жизни. Каждый из алгоритмов оказывается наиболее эффективным в зависимости от конкретных условий. Среди всех алгоритмов сортировки есть группа алгоритмов, которые относят к классике программирования и их знает любой грамотный специалист. Алгоритмы сортировки изучают по следующим основным причинам:
1. они имеют большое практическое значение
2. алгоритмы сортировки - это пример того, как следует подходить к решению задач программирования вообще. На их примере можно увидеть важные принципы манипулирования данными
3. они позволяют продемонстрировать базовые концепции анализа алгоритмов (оценки качества алгоритмов)
4. на примере алгоритмов сортировки легко увидеть как усложнив уже имеющиеся алгоритмы можно получить более эффективный
5. так как все алгоритмы сортировки решают одну и ту же задачу (сортировка данных), то с их помощью можно продемонстрировать как выбор алгоритма влияет на эффективность решения задачи

**Внутренняя сортировка**
Среди внутренних видов сортировки без введения доп. структур данных (массивов) можно в соответствии с принципами их работы выделить 3 группы семейств алгоритмов
1. сортировки с помощью вставок
2. сортировки с помощью выбора
3. сортировки с помощью обмена

Для работы всех алгоритмов потребуется ввести некоторую вспомогательную переменную, она потребуется для временного хранения значения элемента при перестановке элементов. Назовем ее x
**Сортировки с помощью вставок**
Есть отсортированная часть, есть не отсортированная. Берем 1 элемент из не отсортированной и ищем его место в сортированном -> вставляем -> повторяем
Метод простых вставок (просеивания) - Элемент bj помещаем в переменную x. Сравниваем b(j-1) с x. Если b(j-1) < x, то увеличиваем отсортированную часть и берём следующий элемент. Иначе b(j-1) двигаем на место bj.
Тоже самое проделываем с b(j-2) и т.д.
Процесс просеивания заканчивается:
1.  Когда найден элемент bi с ключом меньшим либо равным, чем у рассматриваемого элемента x;
2.  Все элементы упорядоченной части просмотрены, т.е. дошли до левого края и необходимо вставить элемент x первым элементом, т.к. его ключ оказался меньше всех ключей упорядоченной части.
![[Pasted image 20241120145324.png]]
Улучшение метода простых вставок
Делать поиск места для вставки используя метод деления пополам (метод двоичного поиска)
На каждом этапе сортировки элементы продвигаются только на одну позицию. Желательно, чтобы элементы сдвигались с большим шагом.
**Shell-sort**
Каждый проход сортировки характеризуется смешением h, таким, что сортируются записи, каждая из которых отстоящие от предыдущей на h позиций. Суть сортировки состоит в следующем - на каждом проходе сортировки все сортируемые записи делятся на группы. В каждую группу попадают записи, отстоящие друг от друга на h позиций. Затем каждая группа записей сортируется методом простых вставок. На следующем проходе сортировки все записи снова делятся на группы, но отстоящие друг от друга уже на другое меньшее, чем раньше, состояние. Каждая группа записей сортируется методом простых вставок. На последнем этапе шаг будет равен 1. В самом плохом случае на последнем проходе будет проведена оставшаяся сортировка.
Анализ этого алгоритма поставил много проблем с точки зрения математики, которые все еще не разрешены. Существенное значение для скорости это сортировки оказывает выбор значений смещений на последовательных проходах. До сих пор не известно, какие расстояния дают наилучший результат. Желательно, чтобы взаимодействие простых цепочек проходило как можно чаще (например 8, 4, 2, 1)

**Сортировки с помощью выбора** (этот метод не устойчив)
Основная идея заключается в следующем: имеется набор записей – отсортированная и неотсортированная. В этом методе работаем ТОЛЬКО с неотсортированным набором. На i-том этапе сортировки среди элементов bi и bn выбирается элемент bj с наименьшим ключом. Он меняется местами с элементом bi. После этого отсортированная часть увеличивается на 1 элемент.
Эта сортировка начинается с того момента, когда отсортированная часть не существует.
Сортировка заканчивается, когда в неотсортированной части остаётся 1 элемент.
В неотсортированной части ищем минимальный элемент, и если он больше текущего, меняем местами их. Потом идём дальше.
Этот метод работает в среднем быстрее, чем предыдущий.
НИКОГО НИКУДА НЕ ДВИГАЕМ!
 
Метод этот по определению неустойчивый. На экзамене нужно это доказывать. И самому для себя тоже стоит доказать.

**Сортировки с помощью обмена**
На деле все сортировки основываются на обмене значений элементов, но в семействе алгоритмов относящихся по классификации к обменным сортировкам обмен значений является основной операцией, поэтому эти алгоритмы и названы алгоритмами обменной сортировки. Самым известным из этого семейства является метод прямого обмена, который чаще называют методом пузырька
В среднем этот метод считается самым плохим
Метод пузырька
Основная идея метода заключается в следующем: есть набор записей b1, b2, …, bn. Берём пары рядом расположенных элементов и сравниваем между собой. На каждом этапе сортировки мы сравниваем между собой ключи расположенных элементов. Если правый элемент больше, чем левый, то их меняем местами, то сдвигаемся влево. Идём всегда от конца до начала. Когда дошли до первого элемента, мы заканчиваем.
Метод пузырька улучшение
Мы запоминаем были или не были перестановки в процессе некоторого прохода. Если в последнем проходе перестановок не было, то алгоритм можно заканчивать.
Мы запоминаем место или индекс элемента с последним обменом. Все элементы до этого индекса уже упорядочены, следовательно упорядоченную часть мы можем увеличить не на 1 элемент, а до места последнего обмена.

**Быстрая сортировка**
Она относится к улучшенным методам обменных сортировок.
![[Pasted image 20241211142421.png]]
_Для реализации надо много думать._

Суть сортировки: Есть набор записей b1, b2, …bn с ключами k1, k2, … kn. Среди всех ключей, которые имеются, выбираем одно значение как опорное. Мы сами решаем, с какого конца мы имеем первый шаг (можно ходить слева направо или наоборот).

Опорным значением берут почти среднее.

Идя в текущем направлении, ищем первый элемент, значение которого будет больше опорного; при следующем шаге ищем теперь первый элемент, значение которого меньше опорного. Третий шаг – меняем найденные значения. Алгоритм выполняем, пока не дойдём до опорной точки.

Как только поделили массив на 2 равные части, то все элементы слева от опорного, будут меньше его, а справа – больше опорного. Потом меняем опорный элемент. И так далее…

Чисто рекурсивный метод.

Эффективность зависит от того, каким выбираем k опорное. В идеале оно должно быть посередине.

Метод быстрой сортировки является устойчивым, как пузырьковый или шейкером.

Спрашивать на экзамене и лабах, скорее всего, не будут, но знать нужно

**Внешняя сортировка (обменная сортировка с разделением aka quick sort)**

Это всегда сортировка файлов, поэтому будет работать медленней любой самой медленной внутренней сортировки.

Методы внутренней сортировки абсолютно бесполезны для внешней сортировки. Применяется совершенно другой подход. При этом задача сортировки остаётся той же: необходимо расположить записи в файле в порядке неубываемых значений в ключевом поле.

Все методы внешней сортировки основываются на двух основных подходах. У нас есть разделение исходного файла на несколько других, а потом эти файлы сливаем. Этот процесс повторяется многократно.

*рисунок*

Методы отличаются только тем, как исходный файл мы разделяем на другие, а потом их объединяем в итоговый.

Серия – последовательность записей b1, … bn с соответствующими ключами, где bi <= b(i+1) (1<b<k, k - длина).

**По-русски это те данные, которые упорядочены.**

Если m не делится нацело на k, тогда последовательность записей называется хвостом (серия с длиной q).

Сортировку слиянием начинаем с двух файлов, организованных в виде серий длиной, равной k. Для них должны выполняться следующие условия:

1.      Количество серий, включая хвосты, в файле должны отличаться не больше, чем на единицу.
2.      По крайней мере один из файлов имеет хвост, если он получился.
3.      Файл с хвостом имеет не меньше серий, чем другой файл.

Действия по однократной обработке всего множества данных называют фазой. Наименьший подпроцесс, повторение которого составляет процесс сортировки, называется проходом или этапом.

**Двухфазная сортировка прямым слиянием**

Для выполнения этой сортировки нам потребуется 3 файла. Назовём их f, g, t. (лучше по-другому назвать)). При этом считаем, что f – исходный.

1.      Из файла f путём его деления на 2 файла формируем файлы g и t.
2.      Файлы g и t сливаем в файл f. При этом одиночные элементы образуют упорядоченные пары или серии длиной 2.
3.      Полученный файл f обрабатывается согласно пунктам 1 и 2. При этом формируются серии длиной 4.
4.      Повторяем шаги, каждый раз удваивая длину получающихся серий до тех пор, пока не получим серию с длиной, равной числу записей в исходном файле, или одну серию.

По файлу не можем прыгать, считываем записи только последовательно.

**Однофазная сортировка прямым слиянием**

Избавляемся от фазы слияния, фактически бесполезной в плане сортировки

Для данной сортировки нам потребуется 4 файла. Назовём их f1, f2, g1, g2. В ходе сортировки будем чередовать работу с этими файлами. Далее используем следующий алгоритм:

1.      Считаем по одной серии из f1 и f2.
2.      Сливаем эти серии.
3.      Присоединяем результирующую серию длиной 2k к одному из двух файлов – g1 и g2, организованных в виде серий длиной 2k. При этом мы попеременно переключаемся между файлами g1 и g2. Хвост серий файлов f1 и f2 сливается с последним из созданных серий.
4.      Делаем файлы f1 и f2 пустыми.
5.      Повторяем шаги 1-4, меняя файлы f1 на g1, f2 на g2 до тех пор, пока не получим файл с одной серией. Он и будет упорядочен.

**Сортировка естественным слиянием**
В случае прямого слияния мы не получаем никакого преимущества, если данные в начале уже частично упорядочены. Размер сливаемых на входе серий меньше либо равен 2^k и … серий, которые можно просто объединить. Любые 2 серии длиной n и m можно сразу сливать в одну серию из m+n элементов. Сортировка, при которой сливаются 2 самые длинные серии, называется сортировкой естественным слиянием. Для этой сортировки требуются 3 файла (исходный файл f, и вспомогательные файлы g и t). Каждый проход этой сортировки осуществляется следующим образом:
1. из файла f серии попеременно распределяются в файлы g и t (фаза распределения)
2. из файлов g и t серии сливаются в файл f (фаза слияния)
3. процесс заканчивается, как только в файле f останется 1 серия

**Ускорение сортировки прямым слиянием**
Рассмотренные сортировки прямым слиянием начинают свою работу с рассмотрения серий = 1. Для ускорения сортировки можно сделать следующее:
1. считать в оперативную память группы из k записей, но таким образом, чтобы они могли разместиться в оперативной памяти
2. 